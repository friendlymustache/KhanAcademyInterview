Each Node has...

reference to its parent


it's implicitly a graph if each node has a reference
to 



graph keeps track of its own connected components
	

	want a quick way of determining connected component
	sizes

	want an easy way of getting the user_ids at which to begin
	a BFT. basically, 
	
	dict with
	size --> [components represented by a single root node user]

	map from user_id to component

	a single connection can cause two connected components to merge
	which id do we pick? i guess either could work. but do we really
	want to go through and update some component_id thing for each
	user?

	

simplest way:
	
	nodes are just floating around, keep their own adjacency lists
		- both people who coach them and people they coach	
		- memory efficiency not good, but needed to allow easy
		  propagation of infection.
		- to be more space-efficient, can have a many-to-many object
		  representing an edge that we can look up on either end
		- half the space, but lookups would get slow with a huge dict
		  of all the edges

	graph class keeps track of all nodes, performs operations on certain nodes

		- risk -- what about nodes that aren't documented in the graph?


		- could have a dict -- user_id : size
		  to keep track of components


		- add user
		- add coaches or coached_by relationship
			- modify adjacency lists of each user
			- merge reference to root of component
				- add together sizes of components
		- remove user
			- modify adjacency lists of all adjacent users
			- update component graph
				- pick first neighbor and mark that guy as root
				- what if this guy was the link between two components?


		
		- limited infection -- how?
			- build a dict of user ids to component size
				- iterate through all vertices in graph, do a BFT. 					  
				- keep a visited dict. if an id is in the visited dict, 
				  don't do the BFT on it

				- lots of space (linear)
			- do DP on component sizes (values of dict) to get as close as possible
				- 

	
	

	graph object performs total infection on nodes
	
